{*******************************************************************************

  AutoUpgrader Professional
  FILE: auHTTP.pas - auHTTP component. Used as base class for acAutoUpgrader
          in the AppControls v2.3 and later

  Copyright (c) 1998-2004 UtilMind Solutions
  All rights reserved.
  E-Mail: info@utilmind.com
  WWW: http://www.utilmind.com, http://www.appcontrols.com

  The entire contents of this file is protected by International Copyright
Laws. Unauthorized reproduction, reverse-engineering, and distribution of all
or any portion of the code contained in this file is strictly prohibited and
may result in severe civil and criminal penalties and will be prosecuted to
the maximum extent possible under the law.

*******************************************************************************}
{$I auDefines.inc}

unit auHTTP;

interface

uses
  Windows, Classes, Graphics, WinInet,
  auThread, auUtils;

const
  auDefaultProxyPort = 8080;
  auDefaultProxyBypass = '127.0.0.1;';
  DEF_TRANSFERBUFFERSIZE = 4096;
  TEXTHTML = 'text/html';
  DEF_ACCEPT_TYPES = TEXTHTML + ', */*';
{$IFDEF D4}
  S_PIC = 'pic';
{$ELSE}
{  HTTP Response Status Codes: }
  HTTP_STATUS_CONTINUE            = 100;    { OK to continue with request }
  HTTP_STATUS_SWITCH_PROTOCOLS    = 101;    { server has switched protocols in upgrade header }
  HTTP_STATUS_OK                  = 200;    { request completed }
  HTTP_STATUS_CREATED             = 201;    { object created, reason = new URI }
  HTTP_STATUS_ACCEPTED            = 202;    { async completion (TBS) }
  HTTP_STATUS_PARTIAL             = 203;    { partial completion }
  HTTP_STATUS_NO_CONTENT          = 204;    { no info to return }
  HTTP_STATUS_RESET_CONTENT       = 205;    { request completed, but clear form }
  HTTP_STATUS_PARTIAL_CONTENT     = 206;    { partial GET furfilled }
  HTTP_STATUS_AMBIGUOUS           = 300;    { server couldn't decide what to return }
  HTTP_STATUS_MOVED               = 301;    { object permanently moved }
  HTTP_STATUS_REDIRECT            = 302;    { object temporarily moved }
  HTTP_STATUS_REDIRECT_METHOD     = 303;    { redirection w/ new access method }
  HTTP_STATUS_NOT_MODIFIED        = 304;    { if-modified-since was not modified }
  HTTP_STATUS_USE_PROXY           = 305;    { redirection to proxy, location header specifies proxy to use }
  HTTP_STATUS_REDIRECT_KEEP_VERB  = 307;    { HTTP/1.1: keep same verb }
  HTTP_STATUS_BAD_REQUEST         = 400;    { invalid syntax }
  HTTP_STATUS_DENIED              = 401;    { access denied }
  HTTP_STATUS_PAYMENT_REQ         = 402;    { payment required }
  HTTP_STATUS_FORBIDDEN           = 403;    { request forbidden }
  HTTP_STATUS_NOT_FOUND           = 404;    { object not found }
  HTTP_STATUS_BAD_METHOD          = 405;    { method is not allowed }
  HTTP_STATUS_NONE_ACCEPTABLE     = 406;    { no response acceptable to client found }
  HTTP_STATUS_PROXY_AUTH_REQ      = 407;    { proxy authentication required }
  HTTP_STATUS_REQUEST_TIMEOUT     = 408;    { server timed out waiting for request }
  HTTP_STATUS_CONFLICT            = 409;    { user should resubmit with more info }
  HTTP_STATUS_GONE                = 410;    { the resource is no longer available }
  HTTP_STATUS_AUTH_REFUSED        = 411;    { couldn't authorize client }
  HTTP_STATUS_PRECOND_FAILED      = 412;    { precondition given in request failed }
  HTTP_STATUS_REQUEST_TOO_LARGE   = 413;    { request entity was too large }
  HTTP_STATUS_URI_TOO_LONG        = 414;    { request URI too long }
  HTTP_STATUS_UNSUPPORTED_MEDIA   = 415;    { unsupported media type }
  HTTP_STATUS_SERVER_ERROR        = 500;    { internal server error }
  HTTP_STATUS_NOT_SUPPORTED       = 501;    { required not supported }
  HTTP_STATUS_BAD_GATEWAY         = 502;    { error response received from gateway }
  HTTP_STATUS_SERVICE_UNAVAIL     = 503;    { temporarily overloaded }
  HTTP_STATUS_GATEWAY_TIMEOUT     = 504;    { timed out waiting for gateway }
  HTTP_STATUS_VERSION_NOT_SUP     = 505;    { HTTP version not supported }
  HTTP_STATUS_FIRST               = HTTP_STATUS_CONTINUE;
  HTTP_STATUS_LAST                = HTTP_STATUS_VERSION_NOT_SUP;
{$ENDIF}
  HTTP_STATUS_RANGE_NOT_SATISFIABLE = 416;
  // misc strings (for use in application )
  STR_DownloadError   = 'Download Error';
  STR_HostUnreachable = 'Host Unreachable';
  STR_ConnectionLost  = 'Connection Lost';

type
  SetOfChar = set of Char;

  { TauLoginComponent }
  TauLoginComponent = class(TComponent)
  private
    procedure ReadData(Stream: TStream);
    procedure WriteData(Stream: TStream);
  protected
    FLoginUsername, FLoginPassword: String;
      
    procedure DefineProperties(Filer: TFiler); override;
  end;

  { TauHTTP }
  TauHTTPProgressEvent = procedure(Sender: TObject; const ContentType: String;
                                   DataSize, BytesRead,
                                   ElapsedTime, EstimatedTimeLeft: Integer;
                                   PercentsDone: Byte; TransferRate: Single;
                                   Stream: TStream) of object;
{$IFNDEF IE3}
  TauHTTPUploadProgressEvent  = procedure(Sender: TObject;
                                   DataSize, BytesTransferred,
                                   ElapsedTime, EstimatedTimeLeft: Integer;
                                   PercentsDone: Byte; TransferRate: Single) of object;
  TauHTTPUploadFieldRequest   = procedure(Sender: TObject; FileIndex: Word; UploadStream: TMemoryStream; var FieldName, FileName: String) of object;
{$ENDIF}
  TauHTTPHeaderInfoEvent      = procedure(Sender: TObject; ErrorCode: Integer; const RawHeadersCRLF, ContentType, ContentLanguage, ContentEncoding: String;
                                   ContentLength: Integer; const Location: String; const Date, LastModified, Expires: TDateTime; const ETag: String; var ContinueDownload: Boolean) of object;
  TauHTTPStatusChanged        = procedure(Sender: TObject; StatusID: Cardinal; const StatusStr: String) of object;
  TauHTTPRedirected           = procedure(Sender: TObject; const NewURL: String) of object;
  TauHTTPDoneEvent            = procedure(Sender: TObject; const ContentType: String; FileSize: Integer; Stream: TStream) of object;
  TauHTTPConnLostEvent        = procedure(Sender: TObject; const ContentType: String; FileSize, BytesRead: Integer; Stream: TStream) of object;
  TauHTTPErrorEvent           = procedure(Sender: TObject; ErrorCode: Integer; Stream: TStream) of object;
  TauHTTPPasswordRequestEvent = procedure(Sender: TObject; const Realm: String; var TryAgain: Boolean) of object;
  TauHTTPProxyAuthenticationEvent = procedure(Sender: TObject; var ProxyUsername, ProxyPassword: String; var TryAgain: Boolean) of object;
  TauHTTPBeforeSendRequest = procedure(Sender: TObject; hRequest: hInternet) of object;

{$IFNDEF IE3}
  TauHTTPPOSTMethod = (pmFormURLEncoded, pmMultipartFormData);
{$ENDIF}
  TauHTTPRequestMethod = (rmAutoDetect, rmGET, rmPOST);
  TauHTTPAccessType = (atPreconfig, atDirect, atUseProxy);
  TauHTTPProxy = class(TPersistent)
  private
    FAccessType: TauHTTPAccessType;
    FProxyPort: Integer;
    FProxyServer: String;
    FProxyBypass: String;
    FProxyUsername: String;
    FProxyPassword: String;

    function IsUseProxy: Boolean;
  public
    constructor Create;

    procedure Assign(Source: TPersistent); override;
  published
    property AccessType: TauHTTPAccessType read FAccessType write FAccessType default atPreconfig;
    property ProxyPort: Integer read FProxyPort write FProxyPort default auDefaultProxyPort;
    property ProxyServer: String read FProxyServer write FProxyServer stored IsUseProxy;
    property ProxyBypass: String read FProxyBypass write FProxyBypass stored IsUseProxy;
    property ProxyUsername: String read FProxyUsername write FProxyUsername;
    property ProxyPassword: String read FProxyPassword write FProxyPassword;
  end;

  TauHTTPRange = class(TPersistent)
  private
    FStartRange, FEndRange: Cardinal;
  public
    procedure Assign(Source: TPersistent); override;
  published
    property StartRange: Cardinal read FStartRange write FStartRange default 0;
    property EndRange: Cardinal read FEndRange write FEndRange default 0;
  end;

  TauHTTPTimeouts = class(TPersistent)
  private
    FConnectTimeout, FReceiveTimeout, FSendTimeout: DWord;
  public
    procedure Assign(Source: TPersistent); override;  
  published
    property ConnectTimeout: DWord read FConnectTimeout write FConnectTimeout default 0;
    property ReceiveTimeout: DWord read FReceiveTimeout write FReceiveTimeout default 0;
    property SendTimeout: DWord read FSendTimeout write FSendTimeout default 0;
  end;

  TauOutputFileAttributes = class(TPersistent)
  private
    FComplete, FIncomplete: TauFileAttributes;

    procedure SetComplete(const Value: TauFileAttributes);
    procedure SetIncomplete(const Value: TauFileAttributes);
  protected
    procedure AttributesChanged; dynamic;
  public
    constructor Create;
    procedure Assign(Source: TPersistent); override;
  published
    property Complete: TauFileAttributes read FComplete write SetComplete default [atrArchive];
    property Incomplete: TauFileAttributes read FIncomplete write SetIncomplete default [atrArchive, atrTemporary];
  end;

  { TauFileStream - FileStream able to write to opened file (no read lock) }
  TauFileStream = class(THandleStream)
  public
    constructor Create(const FileName: String; CreateNew: Boolean; TestFileAttributes: Boolean {$IFDEF D4} = True {$ENDIF});
    destructor Destroy; override;
  end;

  TauBufferSize = 255..MaxInt;
  TauInternetOption = (ioIgnoreCertificateInvalid, ioIgnoreCertificateDateInvalid,
                       ioIgnoreUnknownCertificateAuthority,
                       ioIgnoreRedirectToHTTP, ioIgnoreRedirectToHTTPS,
                       ioKeepConnection, ioNoAuthentication,
                       ioNoAutoRedirect, ioNoCookies);
  TauInternetOptions = set of TauInternetOption;
  TauCacheOption   = (coAlwaysReload, coReloadIfNoExpireInformation,
                      coReloadUpdatedObjects, coPragmaNoCache,
                      coNoCacheWrite, coCreateTempFilesIfCantCache,
                      coUseCacheIfNetFail);
  TauCacheOptions  = set of TauCacheOption;
  TauCustomHTTP = class(TauLoginComponent)
  private
    FAddHeaders: TStrings;
    FAcceptTypes, FAgent,
    FOutputFileName: String;
    FOutputFileAttributes: TauOutputFileAttributes;
    FURL, FPostData, FReferer: String;
    FCacheOptions: TauCacheOptions;
    FInternetOptions: TauInternetOptions;
    FRange: TauHTTPRange;
    FTimeouts: TauHTTPTimeouts;
    FTransferBufferSize: TauBufferSize;
{$IFNDEF IE3}
    FPOSTMethod: TauHTTPPOSTMethod;
{$ENDIF}
    FRequestMethod: TauHTTPRequestMethod;
    FProxy: TauHTTPProxy;
{$IFNDEF IE3}
    FShowGoOnlineMessage: Boolean;
{$ENDIF}
    FWorkOffline: Boolean;
    FData: Pointer;

    // success events
    FOnBeforeSendRequest: TauHTTPBeforeSendRequest;
    FOnHeaderInfo: TauHTTPHeaderInfoEvent;
    FOnDone: TauHTTPDoneEvent;
    FOnDoneInterrupted: TNotifyEvent;
    FOnProgress: TauHTTPProgressEvent;
    FOnStatusChanged: TauHTTPStatusChanged;
    FOnRedirected: TauHTTPRedirected;
{$IFNDEF IE3}
    FOnUploadProgress: TauHTTPUploadProgressEvent;
    FOnUploadFieldRequest: TauHTTPUploadFieldRequest;
{$ENDIF}
    // error events
    FOnAnyError: TNotifyEvent;
    FOnAborted: TNotifyEvent;
    FOnConnLost: TauHTTPConnLostEvent;
    FOnHostUnreachable: TNotifyEvent;      // no connection
    FOnHTTPError: TauHTTPErrorEvent;       // read error
    FOnOutputFileError: TNotifyEvent;    
    FOnPasswordRequest: TauHTTPPasswordRequestEvent;
    FOnProxyAuthenticationRequest: TauHTTPProxyAuthenticationEvent;
    FOnWaitTimeoutExpired: TauThreadWaitTimeoutExpired;

    // internal events
{$IFDEF USEINTERNAL}
    FOnBeforeCreateFile, FOnAfterCreateFile: TNotifyEvent;
{$ENDIF}

    // internal variables
    FBusy, FRealBusy: Boolean;
    FThread: TauCustomThread;
    HTTPStream: TStream;
    HTTPSuccess, HTTPTryAgain, HTTPOutputToFile,
    HTTPContinueDownload, HTTPDeleteOutputFileOnAbort: Boolean;
    HTTPData: Pointer; // read buffer
    HTTPFileSize, HTTPBytesTransferred, HTTPStartTime,
    HTTPInitStartRange, HTTPInitEndRange: Cardinal;
{$IFNDEF IE3}
    HTTPUploadRequestHeader: String;
{$ENDIF}

    // WinInet handles
    hSession, hConnect, hRequest: hInternet;
    hFile: hFile;

    procedure SetAddHeaders(Value: TStrings);
    function  GetSuspended: Boolean;
    procedure SetSuspended(Value: Boolean);
    function  GetThreadPriority: TThreadPriority;
    procedure SetThreadPriority(Value: TThreadPriority);
    function  GetWaitThread: Boolean;
    procedure SetWaitThread(Value: Boolean);
    function  GetWaitTimeout: Integer;
    procedure SetWaitTimeout(Value: Integer);
    function  GetThreadBusy: Boolean;
    function  GetFreeOnTerminate: Boolean;
    procedure SetFreeOnTerminate(Value: Boolean);
    function  GetFileName: String;
    function  GetHostName: String;

    function  IsNotDefaultAcceptTypes: Boolean;

    procedure PrepareProgressParams;
    procedure CloseHTTPHandles;
    procedure AbortAndReleaseStreams;

    // thread management
    procedure ThreadExecute(Sender: TObject);
    procedure ThreadException(Sender: TObject);
    procedure ThreadDone(Sender: TObject);
    procedure ThreadWaitTimeoutExpired(Sender: TObject; var TerminateThread: Boolean);

    // synchronized methods
    procedure CallAborted;
    procedure CallHeaderInfo;
    procedure CallProgress;
{$IFNDEF IE3}
    procedure CallUploadProgress;
{$ENDIF}
    procedure CallPasswordRequest;
    procedure CallProxyAuthenticationRequest;
{$IFDEF USEINTERNAL}
    procedure CallBeforeCreateFile;
    procedure CallAfterCreateFile;
{$ENDIF}
  protected
    // headers
    HTTPRawHeadersCRLF, HTTPContentType,
    HTTPContentLanguage, HTTPContentEncoding, HTTPLocation, HTTPETag: String;
    HTTPDate, HTTPLastModified, HTTPExpires: TDateTime;

    // for OnProgres/OnUploadProgress events
    ProgressPercentsDone: Byte;
    ProgressElapsedTime, ProgressEstimatedTime: Cardinal;
    ProgressTransferRate: Single;

    procedure DoAnyError;
    procedure ReleaseHTTPStream;
  public
    HTTPErrorCode: Integer;

    constructor Create(aOwner: TComponent); override;
    destructor Destroy; override;

    // public methods
    function  Read{$IFDEF D4}(ForceWaitThread: Boolean = False){$ENDIF}: Boolean;
    function  ReadRange(StartRange: Cardinal; EndRange: Cardinal {$IFDEF D4} = 0; ForceWaitThread: Boolean = False{$ENDIF}): Boolean;
{$IFNDEF IE3}
    function  Upload(NumberOfFields: Word): Boolean;

    function  BeginPrepareUpload: Boolean;
    procedure UploadStream(const FieldName: String; UploadStream: TStream; const FileName: String {$IFDEF D4} = '' {$ENDIF});
    procedure UploadString(const FieldName, StrValue: String);
    procedure UploadInteger(const FieldName: String; IntValue: Integer);
    procedure UploadBoolean(const FieldName: String; BoolValue: Boolean);
    procedure UploadPicture(const FieldName: String; Picture: TPicture;
      const FileName: String {$IFDEF D4} = S_PIC {$ENDIF});
{$IFDEF USEJPEG}
    procedure UploadThumbnailedPicture(const FieldName: String; Picture: TPicture;
      ThumbnailWidth: Word {$IFDEF D4} = DefThumbnailWidth {$ENDIF};
      ThumbnailHeight: Word {$IFDEF D4} = DefThumbnailHeight {$ENDIF};
      JPEGCompressionQuality: Byte {$IFDEF D4} = 90 {$ENDIF};
      WriteNormalImageIfThumbnailHaveBiggerSize: Boolean {$IFDEF D4} = True {$ENDIF};
      const FileName: String {$IFDEF D4} = S_PIC {$ENDIF});
{$ENDIF}
    procedure EndPrepareUpload;
{$ENDIF}
    procedure Abort(DeleteOutputFile: Boolean {$IFDEF D4} = False {$ENDIF}; HardTerminate: Boolean {$IFDEF D4} = False {$ENDIF});

    // new methods (AppControls v3.6.1)
    // works only for binary files. OutputFileName MUST BE SPECIFIED!!
    procedure Pause; // same as Abort(False)
    function  Resume: Boolean;
    function IsGlobalOffline: Boolean;

    // from TacLoginComponent
    property Username: String read FLoginUsername write FLoginUsername stored False;
    property Password: String read FLoginPassword write FLoginPassword stored False;

    // optional properties
    property Busy: Boolean read FBusy;
    property ThreadBusy: Boolean read GetThreadBusy;
    property FreeOnTerminate: Boolean read GetFreeOnTerminate write SetFreeOnTerminate;
    property FileName: String read GetFileName;
    property HostName: String read GetHostName;
    property Thread: TauCustomThread read FThread;

    // public properties
    property AcceptTypes: String read FAcceptTypes write FAcceptTypes stored IsNotDefaultAcceptTypes;
    property AddHeaders: TStrings read FAddHeaders write SetAddHeaders;
    property Agent: String read FAgent write FAgent;
    property Proxy: TauHTTPProxy read FProxy write FProxy;
{$IFNDEF IE3}
    property ShowGoOnlineMessage: Boolean read FShowGoOnlineMessage write FShowGoOnlineMessage default False;    
{$ENDIF}
    property CacheOptions: TauCacheOptions read FCacheOptions write FCacheOptions default [coReloadIfNoExpireInformation, coReloadUpdatedObjects, coCreateTempFilesIfCantCache];
    property InternetOptions: TauInternetOptions read FInternetOptions write FInternetOptions default [ioKeepConnection];
    property OutputFileName: String read FOutputFileName write FOutputFileName;
    property OutputFileAttributes: TauOutputFileAttributes read FOutputFileAttributes write FOutputFileAttributes;
    property URL: String read FURL write FURL;
    property POSTData: String read FPOSTData write FPOSTData;
    property Range: TauHTTPRange read FRange write FRange;
    property Referer: String read FReferer write FReferer;
    property RequestMethod: TauHTTPRequestMethod read FRequestMethod write FRequestMethod default rmAutoDetect;
    property Timeouts: TauHTTPTimeouts read FTimeouts write FTimeouts;
    property TransferBufferSize: TauBufferSize read FTransferBufferSize write FTransferBufferSize default DEF_TRANSFERBUFFERSIZE; // 4Kb
    property WorkOffline: Boolean read FWorkOffline write FWorkOffline default False;
    property Data: Pointer read FData write FData stored False;

    // thread properties
    property Suspended: Boolean read GetSuspended write SetSuspended;
    property ThreadPriority: TThreadPriority read GetThreadPriority write SetThreadPriority default tpNormal;
    property WaitThread: Boolean read GetWaitThread write SetWaitThread default False;
    property WaitTimeout: Integer read GetWaitTimeout write SetWaitTimeout default 0;

    // public events
    property OnBeforeSendRequest: TauHTTPBeforeSendRequest read FOnBeforeSendRequest write FOnBeforeSendRequest;
    property OnHeaderInfo: TauHTTPHeaderInfoEvent read FOnHeaderInfo write FOnHeaderInfo;    
    property OnDone: TauHTTPDoneEvent read FOnDone write FOnDone;
    property OnProgress: TauHTTPProgressEvent read FOnProgress write FOnProgress;
    property OnStatusChanged: TauHTTPStatusChanged read FOnStatusChanged write FOnStatusChanged;
    property OnRedirected: TauHTTPRedirected read FOnRedirected write FOnRedirected;
{$IFNDEF IE3}
    property OnUploadProgress: TauHTTPUploadProgressEvent read FOnUploadProgress write FOnUploadProgress;
    property OnUploadFieldRequest: TauHTTPUploadFieldRequest read FOnUploadFieldRequest write FOnUploadFieldRequest;
{$ENDIF}

    property OnAnyError: TNotifyEvent read FOnAnyError write FOnAnyError;
    property OnAborted: TNotifyEvent read FOnAborted write FOnAborted;
    property OnConnLost: TauHTTPConnLostEvent read FOnConnLost write FOnConnLost;
    property OnDoneInterrupted: TNotifyEvent read FOnDoneInterrupted write FOnDoneInterrupted;
    property OnOutputFileError: TNotifyEvent read FOnOutputFileError write FOnOutputFileError;
    property OnPasswordRequest: TauHTTPPasswordRequestEvent read FOnPasswordRequest write FOnPasswordRequest;
    property OnProxyAuthenticationRequest: TauHTTPProxyAuthenticationEvent read FOnProxyAuthenticationRequest write FOnProxyAuthenticationRequest;
    property OnHostUnreachable: TNotifyEvent read FOnHostUnreachable write FOnHostUnreachable;
    property OnHTTPError: TauHTTPErrorEvent read FOnHTTPError write FOnHTTPError;
    property OnWaitTimeoutExpired: TauThreadWaitTimeoutExpired read FOnWaitTimeoutExpired write FOnWaitTimeoutExpired;
    // internal events
{$IFDEF USEINTERNAL}
    property OnBeforeCreateFile: TNotifyEvent read FOnBeforeCreateFile write FOnBeforeCreateFile;
    property OnAfterCreateFile: TNotifyEvent read FOnAfterCreateFile write FOnAfterCreateFile;
{$ENDIF}
  end;

  // TauHTTPPragmaNoCache
  TauHTTPPragmaNoCache = class(TauCustomHTTP)
  public
    constructor Create(aOwner: TComponent); override;

    property CacheOptions default [coReloadIfNoExpireInformation, coReloadUpdatedObjects, coPragmaNoCache];
  end;

  // TauHTTP
  TauHTTP = class(TauCustomHTTP)
  published
    property AcceptTypes;
    property AddHeaders;
    property Agent;
    property Proxy;
    property URL;
    property Username;
    property CacheOptions;
    property InternetOptions;
    property OutputFileName;
    property OutputFileAttributes;
    property Password;
    property POSTData;
    property Range;
    property Referer;
    property RequestMethod;
{$IFNDEF IE3}
    property ShowGoOnlineMessage;
{$ENDIF}
{$IFDEF USEINTERNAL}
    property Suspended;
{$ENDIF}    
    property Timeouts;
    property ThreadPriority;
    property TransferBufferSize;
    property WaitThread;
    property WaitTimeout;
    property WorkOffline;

    // success
    property OnBeforeSendRequest;
    property OnHeaderInfo;
    property OnDone;
    property OnDoneInterrupted;
    property OnOutputFileError;
    property OnProgress;
{$IFDEF USEINTERNAL}
    property OnStatusChanged;
{$ENDIF}    
    property OnRedirected;
{$IFNDEF IE3}
    property OnUploadProgress;
    property OnUploadFieldRequest;
{$ENDIF}
    // errors
    property OnAnyError;
    property OnAborted;
    property OnConnLost;
    property OnHTTPError;
    property OnHostUnreachable;
    property OnPasswordRequest;
    property OnProxyAuthenticationRequest;
    property OnWaitTimeoutExpired;    
  end;

function HTTPReadString(const URL: String; Timeout: Integer {$IFDEF D4} = 0 {$ENDIF}): String;
{ Encodes the string in manner how the address visible in the browser line
 (Turns unsafe characters to escape codes) }
function URLEncode(const Str: String): String;
{ Decodes the string from manner how the address visible in the browser line to a normal string
  (Unescapes all codes and turns them to normal characters) }
function URLDecode(Str: String): String;
function ParseURL(URL: String; var Protocol, HostName, URLPath,
  Username, Password, ExtraInfo: String; var Port: Word): Boolean;

implementation

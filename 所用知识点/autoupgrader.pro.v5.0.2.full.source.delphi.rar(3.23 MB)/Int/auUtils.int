{*******************************************************************************

  AutoUpgrader Professional
  FILE: auUtils.pas - Various routines

  Copyright (c) 1998-2004 UtilMind Solutions
  All rights reserved.
  E-Mail: info@utilmind.com
  WWW: http://www.utilmind.com, http://www.appcontrols.com

  The entire contents of this file is protected by International Copyright
Laws. Unauthorized reproduction, reverse-engineering, and distribution of all
or any portion of the code contained in this file is strictly prohibited and
may result in severe civil and criminal penalties and will be prosecuted to
the maximum extent possible under the law.

*******************************************************************************}
{$I auDefines.inc}

unit auUtils;

interface

uses Windows, Classes;

var
  EXEDir, EXEName: String; // contains path to current EXE

type
  TauSystemDirectory = (sdCurrentDir,
                        sdDesktop, sdMyDocuments, sdMyPictures,
                        sdAppData, sdProgramFiles, sdWindowsDir,
                        sdSystemDir, sdTempDir, sdHelpDir,
                        sdMediaDir, sdCursorsDir, sdNone);

{ Whether Internet connection active }
function IsOnline: Boolean;
{ Calculates percents. (Result = Round(Part * 100 / Entire)) }
function PercentsOf(Entire, Part: Extended): Byte;
{ Returns executable file by specified extension }
function  GetExecutableByExtension(const Extension: String): String;
{ Opens the specified URL address. In current or new window }
procedure OpenURL(URL: String; InNewWindow: Boolean);
{ returns path to Temporary directory }
function GetTempDir: String;
{ returns path to System directory }
function GetSystemDir: String;
{ returns path to Windows directory }
function GetWindowsDir: String;
{ returns path to a directory by value specified in TacSystemDirectory parameter }
function GetSysDir(Dir: TauSystemDirectory): String;
{ Creates the directory tree }
procedure CreateDirectory(const DirName: String);
{ Determinates wether the directory exists }
function IsDirectoryExists(const DirName: String): Boolean;
{ Expands a path which contains keywords like
%programfiles%, %windows%, %system%, %temp%, %desktop%, %mydocuments%, %mypictures%, %samples%,
%help%, %media%, %cursors%, %appdata%
to real path. For example, line
 %programfiles%\My Application\MyExe.exe could be converted to
 C:\Program Files\My Application\MyExe.exe, or
 %SYSTEMDIR%\mydll.dll could be converted to
 C:\WinNT\system32\mydll.dll }
function ExpandToRealPath(const Path: String; AddCurrentPathAsRoot: Boolean {$IFDEF D4} = True {$ENDIF}): String;
{ True if OS is Windows Vista or higher }
function IsVista: Boolean;


{ Performs "base64" encoding for the strings (size can be up to 2GB)
 return value -- encoded string }
function Base64Encode(const Value: String): String;
{ generates the boundary for multipart data }
function GenerateAttachBoundary(Salt: Char): String;
{ returns MIME-type by file extension }
function GetMIMEType(EXT: String): String;


{ SIMPLE REGISTRY UTILITIES }
{ Whether the key exists in Registry }
function IsRegKeyExists(const KeyName: String; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF}): Boolean;
{ Whether the value exists in Registry }
function IsRegValueExists(const KeyName, ValueName: String; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF}): Boolean;
{ Retreives string from Registry. Returns True if the "KeyName" exists or False otherwise }
function RegGetStr(const KeyName, ValueName: String; var Str: String; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF}): Boolean;
{ Read string from Registry. Returns empty string if failed }
function RegReadStr(const KeyName, ValueName: String; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF}): String;
{ Write string to Registry }
procedure RegWriteStr(const KeyName, ValueName, Value: String; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF});
{ Write string to Registry, to both CURRENT_USER and LOCAL_MACHINE }
procedure RegWriteStrCULM(const KeyName, ValueName, Value: String);
{ Read integer value from Registry. You can specify default value if the key doesn't exists.}
function RegReadInt(const KeyName, ValueName: String; DefaultValue: Integer {$IFDEF D4}=0{$ENDIF}; RootKey: hKey {$IFDEF D4}= HKEY_CURRENT_USER{$ENDIF}): LongInt;
{ Write integer value to Registry }
procedure RegWriteInt(const KeyName, ValueName: String; Value: Integer; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF});
{ Write integer value to Registry, to both CURRENT_USER and LOCAL_MACHINE }
procedure RegWriteIntCULM(const KeyName, ValueName: String; Value: Integer);
{ Read boolean value from Registry. You can specify default value if the key doesn't exists.}
function RegReadBool(const KeyName, ValueName: String; DefaultValue: Boolean {$IFDEF D4}= False{$ENDIF}; RootKey: hKey {$IFDEF D4}= HKEY_CURRENT_USER{$ENDIF}): Boolean;
{ Write boolean value to Registry }
procedure RegWriteBool(const KeyName, ValueName: String; Value: Boolean; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF});
{ Read DateTime value from registry }
function RegReadDateTime(const KeyName, ValueName: String; const DefaultValue: TDateTime {$IFDEF D4}=0{$ENDIF}; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF}): TDateTime;
{ Write DateTime value to registry }
procedure RegWriteDateTime(const KeyName, ValueName: String; const Value: TDateTime; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF});
{ Deletes value from Registry }
procedure RegEraseValue(const KeyName, ValueName: String; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF});
{ Deletes value from Registry, from both CURRENT_USER and LOCAL_MACHINE }
procedure RegEraseValueCULM(const KeyName, ValueName: String);
{ Deletes the registry key and all its subkeys }
procedure RegEraseKey(const KeyName: String; const RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF}; DeleteAllSubkeys: Boolean {$IFDEF D4} = True {$ENDIF});
{ Deletes the registry key and all its subkeys, from both CURRENT_USER and LOCAL_MACHINE }
procedure RegEraseKeyCULM(const KeyName: String; DeleteAllSubkeys: Boolean {$IFDEF D4} = True {$ENDIF});
{ Returns the number of values in a key }
function RegGetValuesCount(const KeyName: String; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF}): DWord;
{ Enumerates Values and puts their names to StringList. Returns False if "KeyName" not exists. }
function RegGetValueNames(const KeyName: String; Strings: TStrings; RootKey: hKey {$IFDEF D4}=HKEY_CURRENT_USER{$ENDIF}): Boolean;


{ STRING / FILENAME ROUTINES (check out AppControls.hlp for reference) }
type
  SetOfChar = set of Char;
  TauSplitStrSide = (LEFT, RIGHT);
  TauSplitStrSides = set of TauSplitStrSide;
procedure SplitStr(SubStr, Str: String;
            var FirstPart, SecondPart: String;
            MainSide: TauSplitStrSide;
            LeaveSeparatorOn: TauSplitStrSides);
function LeftPart(const SubStr, Str: String): String;
function RightPart(const SubStr, Str: String): String;
function LeftPartR(const SubStr, Str: String): String;
function RightPartR(const SubStr, Str: String): String;
function MiddlePart(const SubStr1, SubStr2, Str: String): String;
function PosR(const SubStr, Str: String): Integer;
function PosRM(const Chars: SetOfChar; const Str: String): Integer;
function PosCase(const SubStr, Str: String; IgnoreCase: Boolean {$IFDEF D4} = True {$ENDIF}): Integer;
{$IFNDEF D4}
{ StringReplace replaces occurances of <oldpattern> with <newpattern> in a
  given string.  Assumes the string may contain Multibyte characters }
type
  TReplaceFlags = set of (rfReplaceAll, rfIgnoreCase);
function StringReplace(const S, OldPattern, NewPattern: String; Flags: TReplaceFlags): String;
{$ENDIF}
{$IFNDEF D5}
function  IncludeTrailingBackslash(const St: String): String;
function  ExcludeTrailingBackslash(const St: String): String;
{$ENDIF}
function  IncludeLeadingBackslash(const St: String): String;
function  ExcludeLeadingBackslash(const St: String): String;
function  IncludeLeadingChar(const St: String; Ch: Char {$IFDEF D4} = '\' {$ENDIF}): String;
function  ExcludeLeadingChar(const St: String; Ch: Char {$IFDEF D4} = '\' {$ENDIF}): String;
procedure SplitFilenameAndParams(var FileName, Params: String);

function ParseURL(URL: String; var Protocol, HostName, URLPath,
  Username, Password, ExtraInfo: String; var Port: Word): Boolean;
function URLToHostName(const URL: String): String;
function URLToFileName(const URL: String): String;
{ Compares text, including case sensitivity checking }
function CaseAnsiCompareText(const S1, S2: String; CaseSensitive: Boolean {$IFDEF D4} = True {$ENDIF}): Integer;

{ Compares two strings which contains version number.
  (i.e: compare "2.0.4.0" and "13.46.21.45").
  Returns:
    <0 if NewVersion < OldVersion
    =0 if NewVersion = OldVersion
    >0 if NewVersion > OldVersion
  Modifications: If some section of version number contains
  characters (i.e: "1.02b"), the section will be compared as
  usual string with StrComp(). }
function VersionCheck(const NewVersion, OldVersion: String): ShortInt;


// DATE/TIME routines
{ converts GMT time to local time }
function GMTToLocalTime(GMTTime: TDateTime): TDateTime;
{ converts string representation of Internet date/time into TDateTime }
function InternetTimeToDateTime(InternetTime: String): TDateTime;
{ converts the date/time to FileTime record }
function DateTimeToFileTime(Time: TDateTime): TFileTime;
{ converts the FileTime to Delphi-friendly TDateTime variable }
function FileTimeToDateTime(Time: TFileTime): TDateTime;
{ Specifies the date/time for the file }
function SetFileTimes(const FileName: String; const Created: TDateTime {$IFDEF D4}= -1{$ENDIF}; Modified: TDateTime {$IFDEF D4}= -1{$ENDIF}; Accessed: TDateTime {$IFDEF D4}= -1{$ENDIF}): Boolean;


{ converts the two 32bit Integer to unisgned Extended (float) type }
function Int2x32ToInt64(const IntHi, IntLo: DWord): LongLong;
{ Returns the file size by file name}
function ExtractFileSize(const FileName: String): LongLong;
{ Loads the resource to stream }
function LoadResourceToStream(Instance: hInst; ResName, ResType: PChar; Stream: TStream): Boolean;
{ close the application very quickly }
procedure ShutdownApplication;

{ initialize MS-style record. fill it with 0 and set struct size to first 4 bytes }
procedure InitMSRecord(var Rec; Size: Integer);
{$IFNDEF D3}
function CompareMem(P1, P2: Pointer; Length: Integer): Boolean;
{$ENDIF}

{ wait until StopWait will be called. The process will be suspended on that point which
calls the Wait procedure, until StopWait will be called. After call of StopWait,
the program will continue from next line. }
procedure Wait(var WaitHandle: THandle; Timeout: DWord {$IFDEF D4} = 0 {$ENDIF}; CheckApplicationTermination: Boolean {$IFDEF D4} = True {$ENDIF});
{ stop awaiting of Wait procedure }
procedure StopWait(var WaitHandle: THandle);

{ reads string from stream. The length of output string is the size of stream minus current position of stream }
function StreamToString(Stream: TStream): String;

type
  TauFileAttribute = (atrArchive, atrHidden, atrReadOnly, atrSystem, atrTemporary, atrOffline);
  TauFileAttributes = set of TauFileAttribute;

function SetFileAttr(const FileName: String; const FileAttr: TauFileAttributes): Boolean; // returns True when succeed, False if file not exists
function GetFileAttr(const FileName: String; var FileAttr: TauFileAttributes): Boolean; // returns True when succeed, False if file not exists

const
  CRLF = #13#10;
  D_CRLF = #13#10#13#10;
  HTTPPrefix  = 'http://';

{$IFNDEF D4}
  TIME_ZONE_ID_INVALID = DWORD($FFFFFFFF);
  TIME_ZONE_ID_UNKNOWN  = 0;
  TIME_ZONE_ID_STANDARD = 1;
  TIME_ZONE_ID_DAYLIGHT = 2;
{$ENDIF}
{$IFNDEF D3}
  FILE_ATTRIBUTE_COMPRESSED = $00000800;
  FILE_ATTRIBUTE_OFFLINE    = $00001000;
{$ENDIF}

type
  TDoubleWord = packed record
    case Integer of
      0: (LoWord, HiWord: Word);
      1: (DWord: DWord);
  end;

  { TauStringList }
  TauStringListNVSeparatorSide = (nvsLeft, nvsRight);
  TauStringList = class(TStringList)
  private
    FNVSeparator: String;
    FNVSeparatorMainSide: TauStringListNVSeparatorSide;
    FMaxSize: Integer;

    function  GetName(Index: Integer): String;
    procedure SetName(Index: Integer; const Value: String);
    function  GetValue(Index: Integer): String;
    procedure SetValue(Index: Integer; const Value: String);
    function  GetNVSeparatorPos(Index: Integer): Integer;
  protected
    procedure SetMaxSize(Value: Integer); // virtual;
  public
    constructor Create;
    procedure FreeAndFreeObjects; // destructor inside

    function Add(const S: String): Integer; override;
    procedure DeleteFirstItem;
    procedure DeleteAndFreeObject(Index: Integer);
    procedure ClearAndFreeObjects;

    function IndexOfName(const Name: String; IgnoreCase: Boolean {$IFDEF D4} = True {$ENDIF}): Integer; {$IFDEF D6} reintroduce; {$ENDIF}
    function IndexOfValue(const Value: String; IgnoreCase: Boolean {$IFDEF D4} = True {$ENDIF}): Integer;
    function IndexOfNamePart(const NamePart: String; IgnoreCase: Boolean {$IFDEF D4} = True {$ENDIF}): Integer; // the name contains NamePart
    function IndexOfValuePart(const ValuePart: String; IgnoreCase: Boolean {$IFDEF D4} = True {$ENDIF}): Integer; // the value contains ValuePart

    procedure WriteNamesToFile(const FileName: String);
    procedure WriteValuesToFile(const FileName: String);

    function  GetFIFO: String;
    function  GetAndDeleteItem(Index: Integer): String;

    property NVSeparatorPos[Index: Integer]: Integer read GetNVSeparatorPos;
    property NVSeparator: String read FNVSeparator write FNVSeparator;
    property NVSeparatorMainSide: TauStringListNVSeparatorSide read FNVSeparatorMainSide write FNVSeparatorMainSide default nvsRight;
    property Names[Index: Integer]: String read GetName write SetName;
    property Values[Index: Integer]: String read GetValue write SetValue;

    property MaxSize: Integer read FMaxSize write SetMaxSize default MaxInt;
  end;

implementation
